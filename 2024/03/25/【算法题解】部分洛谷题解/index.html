<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  <title>【算法题解】部分洛谷题解(上) | 日月星辰的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="前言本篇为我做过的洛谷题的部分题解，大多是我认为比较具有代表性的或者比较有意思的题目，包含我自己的思考过程和想法。  [NOIP2001 提高组] 数的划分题目描述将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。 例如：$n&#x3D;7$，$k&#x3D;3$，下面三种分法被认为是相同的。 $1,1,5$;$1,5,1$;$5,1,1$. 问有多少种不同的分法">
<meta property="og:type" content="article">
<meta property="og:title" content="【算法题解】部分洛谷题解(上)">
<meta property="og:url" content="http://example.com/2024/03/25/%E3%80%90%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E3%80%91%E9%83%A8%E5%88%86%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="日月星辰的个人博客">
<meta property="og:description" content="前言本篇为我做过的洛谷题的部分题解，大多是我认为比较具有代表性的或者比较有意思的题目，包含我自己的思考过程和想法。  [NOIP2001 提高组] 数的划分题目描述将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。 例如：$n&#x3D;7$，$k&#x3D;3$，下面三种分法被认为是相同的。 $1,1,5$;$1,5,1$;$5,1,1$. 问有多少种不同的分法">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/03/25/%E3%80%90%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E3%80%91%E9%83%A8%E5%88%86%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/1.png">
<meta property="og:image" content="http://example.com/2024/03/25/%E3%80%90%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E3%80%91%E9%83%A8%E5%88%86%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/2.jpg">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/25xnydfw.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/0hratrdy.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/pic/43224.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/pic/43225.png">
<meta property="article:published_time" content="2024-03-25T01:58:40.000Z">
<meta property="article:modified_time" content="2024-05-03T04:54:42.634Z">
<meta property="article:author" content="cmc">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/03/25/%E3%80%90%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E3%80%91%E9%83%A8%E5%88%86%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/1.png">
  
    <link rel="alternate" href="/atom.xml" title="日月星辰的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/avatar.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/./assets/banner.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>日月星辰的个人博客 </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS Feed">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="Search" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS Feed">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/./assets/avatar.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">日月星辰 </div>
      <div class="dot"></div>
      <div class="subtitle">一个不想拯救世界的技术宅 </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/m0_72845244?type=blog" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/m0_72845244?type=blog" title="Steam"><i class="fa-brands fa-steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/wangchuanfu294" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      



    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Tags</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%AE%89%E5%8D%93-%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91/" rel="tag">安卓&#x2F;鸿蒙开发</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" rel="tag">嵌入式开发</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/" rel="tag">生活随笔</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" rel="tag">目标检测</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%89%B9%E8%AE%AD%E8%90%A5/" rel="tag">算法特训营</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Archives</h3>
      
      
        <a class="archive-link" href="/archives/2024/10 ">
          October 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/08 ">
          August 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/06 ">
          June 2024 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/05 ">
          May 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/04 ">
          April 2024 
          <div class="archive-count">5 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/03 ">
          March 2024 
          <div class="archive-count">7 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/02 ">
          February 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/01 ">
          January 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/12 ">
          December 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/09 ">
          September 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/08 ">
          August 2023 
          <div class="archive-count">6 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/07 ">
          July 2023 
          <div class="archive-count">15 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Recent Posts</h3>
      <ul>
        
          <li>
            <a href="/2024/10/16/%E8%87%AA%E5%AD%A6%E5%B0%8F%E7%99%BD%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%AE%9E%E4%BE%8B/">自学小白的卡尔曼滤波实例</a>
          </li>
        
          <li>
            <a href="/2024/08/21/%E3%80%90Unity%E3%80%91live2d%E5%AF%BC%E5%85%A5%E5%85%8D%E8%B4%B9%E6%A8%A1%E5%9E%8B/">【Unity】快速搭建live2d桌宠</a>
          </li>
        
          <li>
            <a href="/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E3%80%91%E8%A7%A3%E9%A2%98%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">【算法实验】解题实验报告</a>
          </li>
        
          <li>
            <a href="/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E3%80%91%E9%83%A8%E5%88%86%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-%E4%B8%8B/">【算法题解】部分洛谷题解(下)</a>
          </li>
        
          <li>
            <a href="/2024/05/08/%E3%80%90%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E3%80%91%E6%91%8A%E5%88%86%E5%8D%A1%E7%89%8C%EF%BC%8C%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8/">【算法作业】均分卡牌，购买股票</a>
          </li>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-【算法题解】部分洛谷题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        【算法题解】部分洛谷题解(上)
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-03-25T01:58:40.000Z" itemprop="datePublished">2024-03-25</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
    Uncategorized 
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            9.5k words 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇为我做过的洛谷题的部分题解，大多是我认为比较具有代表性的或者比较有意思的题目，包含我自己的思考过程和想法。</p>
<hr>
<h1 id="NOIP2001-提高组-数的划分"><a href="#NOIP2001-提高组-数的划分" class="headerlink" title="[NOIP2001 提高组] 数的划分"></a>[NOIP2001 提高组] 数的划分</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。</p>
<p>例如：$n&#x3D;7$，$k&#x3D;3$，下面三种分法被认为是相同的。</p>
<p>$1,1,5$;<br>$1,5,1$;<br>$5,1,1$.</p>
<p>问有多少种不同的分法。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>$n,k$ （$6&lt;n \le 200$，$2  \le k  \le  6$）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>$1$ 个整数，即不同的分法。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>四种分法为：<br>$1,1,5$;<br>$1,2,4$;<br>$1,3,3$;<br>$2,2,3$.</p>
<p><strong>【题目来源】</strong></p>
<p>NOIP 2001 提高组第二题</p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>其是这题我一看下去觉得纯纯搜索就完了，就直接采用了DFS的思路，考虑一下递归边界，做一个可行性减枝，一顿搜索后就是60分。更换思路，改成从<code>n-k+1</code>到<code>1</code>循环，从后往前遍历i，觉得能够减少循环，把大的数字先找出来，是80分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>,n,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sum,<span class="type">int</span> begin,<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sum&gt;n || num &gt;k) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(sum==n &amp;&amp; k==num)&#123;</span><br><span class="line">		ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for(int i=begin;i&lt;=n-1;i++) //60分，未优化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=begin;i&gt;=<span class="number">1</span>;i--)     <span class="comment">//80分 </span></span><br><span class="line">		<span class="built_in">dfs</span>(sum+i,i,num+<span class="number">1</span>);		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>,n-k+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/25/%E3%80%90%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E3%80%91%E9%83%A8%E5%88%86%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/1.png"></p>
<p>仔细思考后，发现原来是边界条件搞错了。。。</p>
<p>修改后就是100分了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>,n,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sum,<span class="type">int</span> begin,<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sum&gt;n || num &gt;k) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(k==num)&#123;</span><br><span class="line">		<span class="keyword">if</span>(sum==n)</span><br><span class="line">			ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=begin;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		<span class="built_in">dfs</span>(sum+i,i,num+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="comment">//dfs(0,1,0);</span></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>,n-k+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其实这道题还有一种算法思路————动态规划。</p>
<p>f[i][x] 表示 i 分成 x 个非空的数的方案数。</p>
<blockquote>
<p>显然 i&lt;x 时 f[i][x]&#x3D;0 , i&#x3D;x 时 f[i][x]&#x3D;1;</p>
</blockquote>
<p>其余的状态，我们分情况讨论：</p>
<p>①有1的 ②没有1的</p>
<p>第一种情况，方案数为 f[i-1][x-1]</p>
<p>第二种情况，方案数为 f[i-x][x] (此时 i 必须大于 x)</p>
<p>所以，状态转移方程为： f[i][x]&#x3D;f[i-1][x-1]+f[i-x][x]</p>
<p>程序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">201</span>][<span class="number">7</span>]; <span class="comment">// f[k][x] k 分成 x 份 =&#123;f[k-1][x-1],f[k-x][x]&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化边界条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">2</span>; x &lt;= k; x++) &#123;</span><br><span class="line">        f[<span class="number">1</span>][x] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划求解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">2</span>; x &lt;= k; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; x) &#123;</span><br><span class="line">                f[i][x] = f[i - <span class="number">1</span>][x - <span class="number">1</span>] + f[i - x][x];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i][x] = f[i - <span class="number">1</span>][x - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    cout &lt;&lt; f[n][k];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="奇怪的电梯"><a href="#奇怪的电梯" class="headerlink" title="奇怪的电梯"></a>奇怪的电梯</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>感谢 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/101694">yummy</a> 提供的一些数据。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1&#x3D;3$，$K_2&#x3D;3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>共二行。  </p>
<p>第一行为三个用空格隔开的正整数，表示 $N, A, B$（$1 \le N \le 200$，$1 \le A, B \le N$）。</p>
<p>第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，即最少按键次数，若无法到达，则输出 <code>-1</code>。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 1 5</span><br><span class="line">3 3 1 2 5</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>对于 $100 %$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。</p>
<p>本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。</p>
<hr>
<p>这道题也可以多解，我们刚拿到题目的时候，肯定会直接思考模拟然后搜索，这题就可以用dfs或bfs来做。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a,b,k[<span class="number">201</span>],dis[<span class="number">201</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> step)</span></span>&#123;</span><br><span class="line">	dis[node]=step;<span class="comment">//一定可以更新</span></span><br><span class="line">	<span class="type">int</span> v=node-k[node];</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>&lt;=v&amp;&amp;step+<span class="number">1</span>&lt;dis[v]<span class="comment">/*可以更新在搜索*/</span>)<span class="comment">//下</span></span><br><span class="line">		<span class="built_in">dfs</span>(v,step+<span class="number">1</span>);</span><br><span class="line">	v=node+k[node];</span><br><span class="line">	<span class="keyword">if</span>(v&lt;=n&amp;&amp;step+<span class="number">1</span>&lt;dis[v])<span class="comment">//上</span></span><br><span class="line">		<span class="built_in">dfs</span>(v,step+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;k[i];</span><br><span class="line">	<span class="built_in">dfs</span>(a,<span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;(dis[b]==<span class="number">0x3f3f3f3f</span>?<span class="number">-1</span>:dis[b]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注: 这个0x3f3f3f3f是个经验数字，他略小于int的最大值2^31-1的一半</p>
<blockquote>
<p>这题第二个思路就是————<strong>最短路径</strong></p>
</blockquote>
<p>有没有很吃惊！我们可以把每一层楼抽象成图中的节点，然后构建邻接矩阵。然后随便写个Floyd算法就行了(因为本题的数据量比较小，而Floyd算法最简单，五行代码，可以用此方法大材小用)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,a,b,t,i,j,k;</span><br><span class="line">	<span class="type">int</span> e[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>(i==j) e[i][j]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> e[i][j]=inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">		<span class="keyword">if</span>(t+i&lt;=n) e[i][t+i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(i-t&gt;=<span class="number">1</span>) e[i][i-t]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)	</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">				<span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])</span><br><span class="line">					e[i][j]=e[i][k]+e[k][j];</span><br><span class="line">	<span class="type">int</span> ans=e[a][b];</span><br><span class="line">	<span class="keyword">if</span>(ans==inf) <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;				</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h1 id="NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G"><a href="#NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G" class="headerlink" title="[NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G"></a>[NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p>
<p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p>
<p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p>
<p>例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $&#x3D;3+12&#x3D;15$ 。可以证明 $15$ 为最小的体力耗费值。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>共两行。<br>第一行是一个整数 $n(1\leq n\leq 10000)$ ，表示果子的种类数。  </p>
<p>第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1\leq a_i\leq 20000)$ 是第 $i$ 种果子的数目。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 $2^{31}$ 。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">1 2 9</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>对于 $30%$ 的数据，保证有 $n \le 1000$：</p>
<p>对于 $50%$ 的数据，保证有 $n \le 5000$；</p>
<p>对于全部的数据，保证有 $n \le 10000$。</p>
<hr>
<p>这题也有两种方法，总体都为贪心。</p>
<p>第一个方法其实就是上课天天讲的哈夫曼模版题，我这里没有直接使用C++的STL中的优先队列，手搓一个小根堆。时间复杂度为$O(nlogn)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[<span class="number">20010</span>],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t=h[x];</span><br><span class="line">	h[x]=h[y];</span><br><span class="line">	h[y]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftdown</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t,flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i*<span class="number">2</span>&lt;=n &amp;&amp; flag==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(h[i]&gt;h[i*<span class="number">2</span>])</span><br><span class="line">			t=i*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t=i;</span><br><span class="line">		<span class="keyword">if</span>(i*<span class="number">2</span>+<span class="number">1</span>&lt;=n)</span><br><span class="line">			<span class="keyword">if</span>(h[t]&gt;h[i*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line">				t=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(t!=i)&#123;</span><br><span class="line">			<span class="built_in">swap</span>(t,i);</span><br><span class="line">			i=t;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">			flag=<span class="number">1</span>;				</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creat</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		<span class="built_in">siftdown</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">	<span class="comment">//printf(&quot;ee\n&quot;);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">	</span><br><span class="line">	n=num;</span><br><span class="line">	<span class="built_in">creat</span>();       <span class="comment">//建最小堆</span></span><br><span class="line">	 </span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//		printf(&quot;%d &quot;,h[i]);</span></span><br><span class="line"><span class="comment">//	printf(&quot;\n&quot;);</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">		ans+=h[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(n&gt;=<span class="number">3</span> &amp;&amp; h[<span class="number">3</span>]&lt;=h[<span class="number">2</span>])&#123;</span><br><span class="line">				ans+=h[<span class="number">3</span>];</span><br><span class="line">				h[<span class="number">3</span>]+=h[<span class="number">1</span>];	</span><br><span class="line">				<span class="built_in">siftdown</span>(<span class="number">3</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span>	</span><br><span class="line">		<span class="keyword">if</span>((n&gt;=<span class="number">3</span> &amp;&amp; h[<span class="number">2</span>]&lt;=h[<span class="number">3</span>]) || n==<span class="number">2</span>)&#123;</span><br><span class="line">				ans+=h[<span class="number">2</span>];</span><br><span class="line">				h[<span class="number">2</span>]+=h[<span class="number">1</span>];	</span><br><span class="line">				<span class="built_in">siftdown</span>(<span class="number">2</span>);</span><br><span class="line">			&#125;	</span><br><span class="line">		h[<span class="number">1</span>]=h[n--];</span><br><span class="line">		<span class="built_in">siftdown</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//		for(int j=1;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">//			printf(&quot;%d &quot;,h[j]);</span></span><br><span class="line"><span class="comment">//		printf(&quot;\n&quot;);	</span></span><br><span class="line"><span class="comment">//		printf(&quot;ans=%d\n&quot;,ans);</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	printf(&quot;sum=%d\n&quot;,sum);	</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法是建立两个数组，第一个数组存储每堆果子的重量并从小往大排序。从第一个数组中取出前两个就是最小的两堆果子。把这两堆果子取出(从数组中划掉)合并一次成为新的一堆，记录消耗的体力，然后把这两堆果子的总和放在第二的数组后面。接下来还要用同样的方法找到最小的另一堆，合并，也放在第二个数组中，这两个数组都是从小往大排序的，所以两个数组中最小的那一堆一定就在两个数组没有被划掉的元素的最头部。重复这样的操作，直到最后两堆果子被合并。</p>
<p><img src="/2024/03/25/%E3%80%90%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E3%80%91%E9%83%A8%E5%88%86%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/2.jpg"></p>
<p>这种算法时间复杂度还是O($nlogn$)，取决于排序的耗时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 20010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 127</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,a[maxn],b[maxn],m=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">memset</span>(a,MAX,<span class="built_in">sizeof</span>(a));</span><br><span class="line">	<span class="built_in">memset</span>(b,MAX,<span class="built_in">sizeof</span>(b));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 注意a+1,a+n+1; </span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">		<span class="type">int</span> w1=a[i]&lt;b[j] ? a[i++] : b[j++];</span><br><span class="line">		<span class="type">int</span> w2=a[i]&lt;b[j] ? a[i++] : b[j++];</span><br><span class="line"><span class="comment">//		printf(&quot;w1=%d\n&quot;,w1);</span></span><br><span class="line"><span class="comment">//		printf(&quot;w2=%d\n&quot;,w2);</span></span><br><span class="line">		b[++m]=w1+w2;</span><br><span class="line">		ans+=w1+w2;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="NOIP1999-提高组-导弹拦截"><a href="#NOIP1999-提高组-导弹拦截" class="headerlink" title="[NOIP1999 提高组] 导弹拦截"></a>[NOIP1999 提高组] 导弹拦截</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p>
<p>输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行，若干个整数，中间由空格隔开。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">389 207 155 300 299 170 158 65</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>对于前 $50%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。<br>对于后 $50%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。</p>
<p>对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。</p>
<p>此外本题开启 spj，每点两问，按问给分。</p>
<p>NOIP1999 提高组 第一题</p>
<hr>
<p>$\text{upd 2022.8.24}$：新增加一组 Hack 数据。</p>
<hr>
<blockquote>
<p>1999年的经典老题。一个非升序列的dp加上贪心是可以解决的，大家都会做，本来是很简单的，但是后来加强了数据，这题的第一问dp还需要二分优化。</p>
</blockquote>
<p>以下是个洛谷大佬的题解。</p>
<h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><p>将拦截的导弹的高度提出来成为原高度序列的一个子序列，根据题意这个子序列中的元素是单调不增的（即后一项总是不大于前一项），我们称为<strong>单调不升子序列</strong>。本问所求能拦截到的最多的导弹，即求<strong>最长的单调不升子序列</strong>。</p>
<p>考虑记 $dp_{i}$ 表示「对于前 $i$ 个数，在选择第 $i$ 个数的情况下，得到的单调不升子序列的长度最长是多少」。于是可以分两种情况：</p>
<ul>
<li>第 $i$ 个数是子序列的第一项。则 $\mathit{dp}_i\gets 1$。</li>
<li>第 $i$ 个数不是子序列的第一项。选择的第 $i$ 个数之前选择了第 $j$ 个数。根据题意，第 $j$ 个数的值 $h(j)$ 应当小于第 $i$ 个数的值 $h(i)$。枚举这样的 $j$，可以得到状态转移方程：</li>
</ul>
<p>$$\mathit{dp}<em>i&#x3D;\max</em>{j&lt;i,h(j)\ge h(i)} {\mathit{dp_j}+1}$$</p>
<p>综合这两种情况，得到最终的状态转移方程：</p>
<p>$$\mathit{dp}<em>i&#x3D;\max{1,\max</em>{j&lt;i,h(j)\ge h(i)}{\mathit{dp}_j+1}}$$</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/25xnydfw.png"></p>
<p>值得注意的是，第 $n$ 个数不一定是最长单调不升子序列的最后一项。为了求出答案，我们需要枚举最后一项是哪个：</p>
<p>$$\mathit{ans}&#x3D;\max_{1\le i\le n}{\mathit{dp}_i}$$</p>
<p>直接枚举进行状态转移，时间复杂度显然是 $ O(n^2)$。<br>下面考虑优化。</p>
<p>记 $f_i$ 表示「对于<strong>所有</strong>长度为 $i$ 的单调不升子序列，它的最后一项的大小」的最大值。特别地，若不存在则 $f_i&#x3D;0$。下面证明：</p>
<ul>
<li>随 $i$ 增大，$f_i$ 单调不增。即 $f_i\ge f_{i+1}$。</li>
</ul>
<p>考虑使用反证法。假设存在 $u&lt;v$，满足 $f_u&lt;f_v$。考虑长度为 $v$ 的单调不升子序列，根据定义它以 $f_v$ 结尾。显然我们可以从该序列中挑选出一个长度为 $u$ 的单调不升子序列，它的结尾同样是 $f_v$。那么由于 $f_v&lt;f_u$，与 $f_u$ 最大相矛盾，得出矛盾。</p>
<p>因此 $f_i$ 应该是单调不增的。</p>
<p>现在考虑以 $i$ 结尾的单调不升子序列的长度的最大值 $\mathit{dp}_i$。由于我们需要计算所有满足 $h(j)&lt;h(i)$ 的 $j$ 中，$\mathit{dp}_j$ 的最大值，不妨考虑这个 $\mathit{dp}_j$ 的值是啥。设 $\mathit{dp}_j&#x3D;x$，那么如果 $h(i)&gt;f_x$，由于 $f_x\ge h(j)$，就有 $h(i)&gt;h(j)$，矛盾，因此总有 $h(i)\le f_x$。</p>
<p>根据刚刚得出的结论，$f_i$ 单调不增，因此我们要找到尽可能大的 $x$ 满足 $h(i)\le f_x$。考虑二分。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/0hratrdy.png"></p>
<p>绿色区域表示合法的 $f_x$（即 $ f_x &lt; h(i) $），红色区域表示不合法的 $f_x$（即 $f_x &lt; h(i)$），我们需要找到红绿之间的交界点。</p>
<p>假设二分区域为 $[l,r)$（注意开闭区间。图上黄色区域标出来了二分区域内实际有效的元素）。每次取 $m&#x3D;\frac{l+r}{2}$，如果 $f_m$ 在绿色区域内，我们就把 $l$ 移动到此处（$l\gets m$）；否则把 $r$ 移动到此处（$r\gets m$）。</p>
<p>当 $r-l&#x3D;1$ 时，$l$ 处位置即为我们需要找的位置。转移 $\mathit{dp}<em>i\gets l+1$ 即可。记得更新 $f$。但是我们只用更新 $f</em>{\mathit{dp}<em>i}$，这是因为 $f_1,f_2,\cdots f</em>{\mathit{dp_i}-1}$ 的大小肯定都是不小于 $h(i)$ 的。$f_{\mathit{dp}<em>i}$ 是最后一个不小于 $h(i)$ 的位置，$f</em>{\mathit{dp}_i+1}$ 则小于 $h(i)$。</p>
<p>时间复杂度 $ O(nlogn)$，可以通过该问。</p>
<h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><p>考虑贪心。</p>
<p>从左到右依次枚举每个导弹。假设现在有若干个导弹拦截系统可以拦截它，那么我们肯定选择这些系统当中位置最低的那一个。如果不存在任何一个导弹拦截系统可以拦截它，那我们只能新加一个系统了。</p>
<p>假设枚举到第 $i$ 个导弹时，有 $m$ 个系统。我们把这些系统的高度按照从小到大排列，依次记为 $g_1,g_2,\cdots g_m$。容易发现我们就是要找到最小的 $g_x$ 满足 $g_x\ge h_i$（与第一问相同，这是可以二分得到的），然后更新 $g_x$ 的值。更新之后，$g_1,g_2\cdots g_x$ 显然还是单调不增的，因此不用重新排序；如果找不到符合要求的导弹拦截系统，那就说明 $g_m &lt; h_i$，直接在后头增加一个就行。</p>
<p>时间复杂度 $ O(nlogn)$，可以通过该问。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>&amp;lt;bits/stdc++.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> up(l,r,i) for(int i=l,END##i=r;i&amp;lt;=END##i;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dn(r,l,i) for(int i=r,END##i=l;i&amp;gt;=END##i;--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF =<span class="number">2147483647</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n,t,H[MAXN],F[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(&amp;quot;%d&amp;quot;,&amp;amp;H[++n])); --n;</span><br><span class="line">    t=<span class="number">0</span>,<span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F)),F[<span class="number">0</span>]=INF;</span><br><span class="line">    <span class="built_in">up</span>(<span class="number">1</span>,n,i)&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=t+<span class="number">1</span>; <span class="keyword">while</span>(r-l&amp;gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(F[m]&amp;gt;=H[i]) l=m; <span class="keyword">else</span> r=m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x=l+<span class="number">1</span>;  <span class="comment">// dp[i]</span></span><br><span class="line">        <span class="keyword">if</span>(x&amp;gt;t) t=x; F[x]=H[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;quot;%d\n&amp;quot;,t);</span><br><span class="line">    t=<span class="number">0</span>,<span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F)),F[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">up</span>(<span class="number">1</span>,n,i)&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=t+<span class="number">1</span>; <span class="keyword">while</span>(r-l&amp;gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(F[m]&amp;lt;H[i]) l=m; <span class="keyword">else</span> r=m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x=l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;gt;t) t=x; F[x]=H[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;quot;%d\n&amp;quot;,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察第二问的代码，与第一问进行比较，可以发现这段代码<strong>等价于</strong>计算最长上升子序列（严格上升，即后一项大于前一项）。这其实是 $\text{Dilworth}$ 定理（将一个序列剖成若干个单调不升子序列的最小个数等于该序列最长上升子序列的个数），本处从代码角度证明了该结论。</p>
<hr>
<h1 id="NOIP2003-普及组-栈"><a href="#NOIP2003-普及组-栈" class="headerlink" title="[NOIP2003 普及组] 栈"></a>[NOIP2003 普及组] 栈</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。</p>
<p>栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。</p>
<p>栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。</p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png"></p>
<p>宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。</p>
<p>现在可以进行两种操作，</p>
<ol>
<li>将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）</li>
<li>将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）</li>
</ol>
<p>使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 <code>1 2 3</code> 生成序列 <code>2 3 1</code> 的过程。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png"></p>
<p>（原始状态如上图所示）</p>
<p>你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。</p>
<h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件只含一个整数 $n$（$1 \leq n \leq 18$）。</p>
<h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件只有一行，即可能输出序列的总数目。</p>
<h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p><strong>【题目来源】</strong></p>
<p>NOIP 2003 普及组第三题</p>
<hr>
<p>这道题关于一个上课时老师提了一嘴的Catalan(卡特兰数)。这道题要动手动笔，找到数的规律。</p>
<p>我们只要顺着递归的思路来就好了：</p>
<ol>
<li>据上面的递归，可知定义的 $f[i,j]$ 中 $i&#x3D;0$ 时这个数组的值都为1，同时，这也是递推边界。并且，我们用 $i$ 表示队列里的数，$j$ 表示出栈数，$f[i,j]$表示情况数；</li>
<li>既然我们愉快地得到了递推思路，愣着干嘛，因为即使初始化了我们也不可能直接用递归的思路写出递归！所以开始找规律：$f[i,j]$到底与什么有着不可告人的联系？其实这个很容易可以想到：当 $i$ 个数进栈，$j-1$ 个数出栈的时候，只要再出一个数，便是i个数进栈，$j$ 个数出栈的情况，同理，对于进栈 $i-1$ 个数，出栈   $j$个数，在进栈一个数便是$f[i,j]$了，于是就有了递归式：$f[i,j]&#x3D;f[i-1,j+1]$.</li>
<li>然而事实上这还没有完，因为 $i&#x3D;j$ 时，栈空了，那么，此时就必须进栈了，则$i-1$，有$f[i,j]&#x3D;f[i-1,j]$；解释一下为什么这样会栈空：当队列和出栈的数都有i个数时，数的总数为 $2i$ ，很明显的，栈里面没有元素了！</li>
</ol>
<ul>
<li><strong>递推式：</strong></li>
</ul>
<blockquote>
<p>$f[n]&#x3D;f[0]*f[n-1] + f[1]*f[n-2] + … + f[n-1]*f[0] (n≥2)$</p>
</blockquote>
<p>完整代码就只有这么长。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, h[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">	h[<span class="number">0</span>]=h[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">			h[i]+=h[j]*h[i-j<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,h[n]);		 </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h1 id="NOIP2010-提高组-关押罪犯"><a href="#NOIP2010-提高组-关押罪犯" class="headerlink" title="[NOIP2010 提高组] 关押罪犯"></a>[NOIP2010 提高组] 关押罪犯</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2010 提高组 T3</p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。</p>
<p>每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。</p>
<p>在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。</p>
<p>那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？</p>
<h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>每行中两个数之间用一个空格隔开。第一行为两个正整数 $N,M$，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 $M$ 行每行为三个正整数 $a_j,b_j,c_j$，表示 $a_j$ 号和 $b_j$ 号罪犯之间存在仇恨，其怨气值为 $c_j$。数据保证 $1&lt;a_j\leq b_j\leq N, 0 &lt; c_j\leq 10^9$，且每对罪犯组合只出现一次。</p>
<h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 <code>0</code>。</p>
<h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4 6</span><br><span class="line">1 4 2534</span><br><span class="line">2 3 3512</span><br><span class="line">1 2 28351</span><br><span class="line">1 3 6618</span><br><span class="line">2 4 1805</span><br><span class="line">3 4 12884</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3512</span><br></pre></td></tr></table></figure>

<h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p><strong>输入输出样例说明</strong></p>
<p>罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png"></p>
<p><strong>数据范围</strong>  </p>
<p>对于 $30%$ 的数据有 $N\leq 15$。</p>
<p>对于 $70%$ 的数据有 $N\leq 2000,M\leq 50000$。  </p>
<p>对于 $100%$ 的数据有 $N\leq 20000,M\leq 100000$。</p>
<hr>
<blockquote>
<p>这可能是我在这里放的知识难度最高的题目了，涉及<strong>种类并查集</strong>，虽然在洛谷中排行为一道绿题，但是只要各种并查集知识牢靠，想到思路还是挺容易。对，就是那种<code>朋友的朋友是朋友，敌人的敌人是朋友</code>。<code>朋友的朋友</code>还好处理，直接划在同一个集合就行了，但是<code>敌人的敌人</code>怎么处理呢？请看下面题解。</p>
</blockquote>
<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>在数据结构并查集中，种类并查集属于扩展域并查集一类。</p>
<p>比较典型的题目就是：<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P2024">食物链</a>（比本题难一些，有三个种类存在）</p>
<p>首先讲一下本题的贪心，这个是必须要懂的。我们假设最后Z 市长看到的那个冲突事件的影响力为 x （也就是有一对仇恨值为 x 的罪犯在同一监狱）那么比 x 仇恨值更高的每一对罪犯必须分配到不同的监狱（不然，最终答案就不是 x ，而是这一对罪犯的仇恨值了）；</p>
<p>所以本题是存在单调性的，只需要从大到小枚举仇恨值，到那一对与前面出现矛盾了，直接输出即可；</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>种类并查集中“种类”这个词也不是绝对的，它也可以说是一种关系，而本题的关系就在于要将罪犯分配到的<strong>两个监狱</strong>；我们可以将数组开到两倍来模拟这两个监狱（用A，B表示），每个罪犯在监狱中都有一个位置。</p>
<p>假设现在要把两个有仇的罪犯分别放到 A 或 B 中，我们发现如果要满足这一对的要求（即分到的监狱不同），那么如果第一个罪犯在 A 监狱，第二个罪犯必须在 B 监狱，反之也一样。</p>
<p>所以我们可以将 A 监狱中第一个罪犯的位置与 B 监狱中第二个罪犯的位置用并查集维护，即这样合并才能保证分到的监狱不一样。但第一个罪犯不一定只能在 A 监狱，所以我们将 B 监狱中 第一个罪犯的位置与 A 监狱中第二个罪犯的位置维护。</p>
<p>而出现矛盾的情况，举个例子： a 和 c 有仇，b 和 c 有仇，那么此时 a 和 c 在不同监狱，b 和 c 也在不同监狱，也就是说 a 和 b 一定在一个监狱。可一旦此时 a 和 b 有仇那么就矛盾了，因为a 和 b 要在不同监狱不然会有矛盾，可 a 和 b 已经在之前判定为必须在同一监狱，所会矛盾，此时就可以直接输出 a 和 b 的仇恨值（原理参见前言的贪心）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">20005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM=<span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>*MAXN]; <span class="comment">// 开两倍数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Relationship</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,v;</span><br><span class="line">&#125;r[<span class="number">2</span>*MAXM];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Relationship a,Relationship b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==f[x]?x:f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fx=<span class="built_in">find</span>(x);</span><br><span class="line">	<span class="type">int</span> fy=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(fx != fy)</span><br><span class="line">		f[fx]=fy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">		f[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;r[i].x,&amp;r[i].y,&amp;r[i].v);</span><br><span class="line">	<span class="built_in">sort</span>(r+<span class="number">1</span>,r+m+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(r[i].x)==<span class="built_in">find</span>(r[i].y))&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r[i].v);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">merge</span>(r[i].x+n,r[i].y);</span><br><span class="line">			<span class="built_in">merge</span>(r[i].y+n,r[i].x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="USACO05FEB-Aggressive-cows-G"><a href="#USACO05FEB-Aggressive-cows-G" class="headerlink" title="[USACO05FEB] Aggressive cows G"></a>[USACO05FEB] Aggressive cows G</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>农夫约翰建造了一座有 $n$ 间牛舍的小屋，牛舍排在一条直线上，第 $i$ 间牛舍在 $x_i$ 的位置，但是约翰的 $m$ 头牛对小屋很不满意，因此经常互相攻击。约翰为了防止牛之间互相伤害，因此决定把每头牛都放在离其它牛尽可能远的牛舍。也就是要最大化最近的两头牛之间的距离。</p>
<p>牛们并不喜欢这种布局，而且几头牛放在一个隔间里，它们就要发生争斗。为了不让牛互相伤害。约翰决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是多少呢？</p>
<h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行用空格分隔的两个整数 $n$ 和 $m$；</p>
<p>第二行为 $n$ 个用空格隔开的整数，表示位置 $x_i$。</p>
<h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示最大的最小距离值。</p>
<h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 2 8 4 9</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>把牛放在 $1$，$4$，$8$ 这三个位置，距离是 $3$。容易证明最小距离已经最大。</p>
<p>对于 $100%$ 的数据，$2 \le n \le 10^5$，$0 \le x_i \le 10^9$，$2 \le m \le n$。</p>
<p>不保证 $a$ 数组单调递增。</p>
<hr>
<blockquote>
<p>一个非常经典的二分答案例题，常常放在学校里市里的中小学NOIP选拔赛中。</p>
</blockquote>
<p>一般我们根据经验看到什么指标<strong>最小的最大</strong>，<strong>最大的最小</strong>就可以判断这题就是一道二分答案题。</p>
<p>什么是二分答案？简单地说，就是和二分查找相似，二分每个答案，然后对这个答案进行求证，看是否满足条件，然后再次进行左右区间查找，直到二分到单个点上。</p>
<p>二分答案主要就是<strong>检验函数</strong>难写,check()本来就是二分答案的考察点。</p>
<p>对了，这题走来还要先排个序，直接上代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>],n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,last=-INF;</span><br><span class="line">	<span class="comment">//k记录入住隔间的牛数量,last记录上一头牛的位置 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(a[i]-last&gt;=dis)&#123;<span class="comment">//能安置就安置 </span></span><br><span class="line">			last = a[i]; </span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> k&gt;=m;</span><br><span class="line">	<span class="comment">//如果k&gt;=m说明入住的牛多了，这个解ans小了，要向右查找	</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);<span class="comment">//从小大快排 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//二分答案的标准模版 </span></span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=INF,ans,mid;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="NOIP2018-普及组-龙虎斗"><a href="#NOIP2018-普及组-龙虎斗" class="headerlink" title="[NOIP2018 普及组] 龙虎斗"></a>[NOIP2018 普及组] 龙虎斗</h1><h2 id="题目背景-3"><a href="#题目背景-3" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2018 普及组 T2</p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>轩轩和凯凯正在玩一款叫《龙虎斗》的游戏，游戏的棋盘是一条线段，线段上有 $n$ 个兵营（自左至右编号 $1 \sim n$），相邻编号的兵营之间相隔 $1$ 厘米，即棋盘为长度为 $n-1$ 厘米的线段。$i$ 号兵营里有 $c_i$位工兵。 下面图 1 为 $n&#x3D;6$ 的示例： </p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/43224.png">    </p>
<p>轩轩在左侧，代表“龙”；凯凯在右侧，代表“虎”。 他们以 $m$ 号兵营作为分界， 靠左的工兵属于龙势力，靠右的工兵属于虎势力，而第 $m$ 号兵营中的工兵很纠结，他们不属于任何一方。    </p>
<p>一个兵营的气势为：该兵营中的工兵数$ \times $ 该兵营到 $m$ 号兵营的距离；参与游戏 一方的势力定义为：属于这一方所有兵营的气势之和。<br>下面图 2 为 $n &#x3D; 6,m &#x3D; 4$ 的示例，其中红色为龙方，黄色为虎方：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/43225.png">  </p>
<p>游戏过程中，某一刻天降神兵，共有 $s_1$ 位工兵突然出现在了 $p_1$ 号兵营。作为轩轩和凯凯的朋友，你知道如果龙虎双方气势差距太悬殊，轩轩和凯凯就不愿意继续玩下去了。为了让游戏继续，你需要选择一个兵营 $p_2$，并将你手里的 $s_2$ 位工兵全部派往 兵营 $p_2$，使得双方气势差距尽可能小。 </p>
<p> 注意：你手中的工兵落在哪个兵营，就和该兵营中其他工兵有相同的势力归属（如果落在 $m$ 号兵营，则不属于任何势力）。</p>
<h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第一行包含一个正整数$n$，代表兵营的数量。  </p>
<p>接下来的一行包含 $n$ 个正整数，相邻两数之间以一个空格分隔，第 $i$ 个正整数代 表编号为 $i$ 的兵营中起始时的工兵数量 $c_i$。  </p>
<p>接下来的一行包含四个正整数，相邻两数间以一个空格分隔，分别代表 $m,p_1,s_1,s_2$。</p>
<h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件有一行，包含一个正整数，即 $p_2$，表示你选择的兵营编号。如果存在多个编号同时满足最优，取最小的编号。</p>
<h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6 </span><br><span class="line">2 3 2 3 2 3 </span><br><span class="line">4 6 5 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6 </span><br><span class="line">1 1 1 1 1 16 </span><br><span class="line">5 4 1 1</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p><strong>样例 1 说明</strong>   </p>
<p>见问题描述中的图 2。<br>双方以 $m&#x3D;4$ 号兵营分界，有 $s_1&#x3D;5$ 位工兵突然出现在 $p_1&#x3D;6$ 号兵营。<br>龙方的气势为：<br>$$2 \times (4-1)+3 \times (4-2)+2 \times (4-3) &#x3D; 14$$<br>虎方的气势为：<br>$$2 \times  (5 - 4) + (3 + 5) \times (6 - 4) &#x3D; 18$$<br>当你将手中的 $s_2 &#x3D; 2$ 位工兵派往 $p_2 &#x3D; 2$ 号兵营时，龙方的气势变为：<br>$$14 + 2 \times  (4 - 2) &#x3D; 18$$<br>此时双方气势相等。 </p>
<p><strong>样例 2 说明</strong>   </p>
<p>双方以 $m &#x3D; 5$ 号兵营分界，有 $s_1 &#x3D; 1$ 位工兵突然出现在 $p_1 &#x3D; 4$ 号兵营。<br>龙方的气势为：<br>$$1 \times  (5 - 1) + 1 \times  (5 - 2) + 1 \times  (5 - 3) + (1 + 1) \times  (5 - 4) &#x3D; 11$$<br>虎方的气势为：<br>$$16 \times  (6 - 5) &#x3D; 16$$<br>当你将手中的 $s_2 &#x3D; 1$ 位工兵派往 $p_2 &#x3D; 1$ 号兵营时，龙方的气势变为：<br>$$11 + 1 \times  (5 - 1) &#x3D; 15$$<br>此时可以使双方气势的差距最小。</p>
<p><strong>数据规模与约定</strong>    </p>
<p>$1 &lt; m &lt; n,1 ≤ p_1 ≤ n$。<br>对于 $20%$ 的数据，$n &#x3D; 3,m &#x3D; 2, c_i &#x3D; 1, s_1,s_2 ≤ 100$。<br>另有 $20%$ 的数据，$n ≤ 10, p_1 &#x3D; m, c_i &#x3D; 1, s_1,s_2 ≤ 100$。<br>对于 $60%$ 的数据，$n ≤ 100, c_i &#x3D; 1, s_1,s_2 ≤ 100$。<br>对于 $80%$ 的数据，$n ≤ 100, c_i,s_1,s_2 ≤ 100$。<br>对于 $100%$ 的数据，$n≤10^5$,$c_i,s_1,s_2≤10^9$。</p>
<hr>
<blockquote>
<p>最后，为什么要放这道题呢，这道题其实是我当年初二时OI的考试题，我非常有印象，当时还压线考了个普及组一等，这道就是只有六十几分。</p>
</blockquote>
<p>首先……这题我在考场上打了一个暴力</p>
<p>当时我觉得这题很简单，就是先输入，p1位置加s1个工兵，然后依次枚举把s2个工兵放在所有的兵营里，每次算一遍双方势力之差，取最小就行了</p>
<p>然而我万万没想到竟然超时了……</p>
<p>详见代码，接下来解释为什么超时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, p1, s1, s2, a[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//计算双方势力之差</span></span><br><span class="line">    <span class="type">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;<span class="comment">//计算左边和右边</span></span><br><span class="line">    a[x] += s2;<span class="comment">//先假设位置x加上s2个工兵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == m) <span class="keyword">continue</span>;<span class="comment">//m号兵营跳过</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; m) sum1 += (m - i) * a[i];<span class="comment">//m左边的兵营</span></span><br><span class="line">        <span class="keyword">else</span> sum2 += (i - m) * a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[x] -= s2;<span class="comment">//再减去s2个，因为是假设加上了s2个工兵</span></span><br><span class="line">    <span class="keyword">if</span>(sum1 &gt;= sum2) <span class="keyword">return</span> sum1 - sum2; <span class="keyword">return</span> sum2 - sum1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> min = <span class="number">2e8</span>, where;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;m, &amp;p1, &amp;s1, &amp;s2);</span><br><span class="line">    </span><br><span class="line">    a[p1] += s1;<span class="comment">//加上s1个工兵</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="built_in">compute</span>(i);<span class="comment">//算一下势力之差</span></span><br><span class="line">        <span class="keyword">if</span>(min &gt; tmp) &#123;<span class="comment">//如果比之前的最小还小（因为如果势力之差一样小就取编号小的，所以没等号）</span></span><br><span class="line">            min = tmp;</span><br><span class="line">            where = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, where);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么超时了呢？原因在于每次都算了一遍势力之差。</p>
<p>时间复杂度是$O(n^2)$</p>
<p>啥？那咋办？</p>
<p>就提前算好龙方和虎方的势力之差，每次枚举的时候就直接算一下新的势力之差就行了</p>
<p>别着急，没完呢，别抄这个，<del>因为也是错的</del></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">abs</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="comment">//相减后再算绝对值</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt;= y) <span class="keyword">return</span> x - y;</span><br><span class="line">    <span class="keyword">return</span> y - x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, p1, s1, s2, a[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> min = <span class="number">2e8</span>, where;</span><br><span class="line">    <span class="type">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;<span class="comment">//分别提前算好左边和右边的势力</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;m, &amp;p1, &amp;s1, &amp;s2);</span><br><span class="line">    </span><br><span class="line">    a[p1] += s1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m) sum1 += (m - i) * a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; m) sum2 += (i - m) * a[i];<span class="comment">//这是预处理，算好左边和右边的势力之差</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m) sum1 += (m - i) * s2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; m) sum2 += (i - m) * s2;<span class="comment">//算出新的双方势力</span></span><br><span class="line">        <span class="type">int</span> tmp = <span class="built_in">abs</span>(sum1, sum2);<span class="comment">//相减后算绝对值</span></span><br><span class="line">        <span class="keyword">if</span>(min &gt; tmp) &#123;</span><br><span class="line">            min = tmp;</span><br><span class="line">            where = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m) sum1 -= (m - i) * s2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; m) sum2 -= (i - m) * s2;<span class="comment">//退栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, where);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>满怀激动地提交，结果，后五个点WA了。。。</p>
<p>问题出在哪里？</p>
<p>原因是没开$long$ $long$。。。</p>
<p>因为虽然一个数$int$存的下，但加起来可是会超过$int$的啊！</p>
<p>（估算了下，在$1e18$ ~ $9e18$之间，$long$ $long$刚好够）</p>
<p><del>可恶的CCFNOI，竟然卡你longlong</del></p>
<p>于是，开成$long$ $long$就过了。</p>
<blockquote>
<p>十年OI一场空，不开longlong见祖宗</p>
</blockquote>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本篇为洛谷题解前8篇。虽然我早早就退出OI的圈子，但是我仍然还会想起当年的刷题经历。最后祝大家天天AC，AK。</p>
<hr>
<p>参考链接:</p>
<p>【关押罪犯】<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/9ur7i0xl">https://www.luogu.com.cn/article/9ur7i0xl</a></p>
<p>【[NOIP1999 普及组] 导弹拦截】<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/yc19s69p">https://www.luogu.com.cn/article/yc19s69p</a></p>
<p>【栈】<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/vj5wm9da">https://www.luogu.com.cn/article/vj5wm9da</a></p>
<p>【进击的奶牛】<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/fys1hulp">https://www.luogu.com.cn/article/fys1hulp</a></p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2024/04/10/%E3%80%90%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E3%80%91%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B3%A2%E8%B0%B7/"
      title="【算法作业】连续序列的最大波谷"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        【算法作业】连续序列的最大波谷
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/03/22/%E3%80%90%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E3%80%91%E6%AC%A1%E6%95%B0%E4%B8%8D%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%97%E7%AC%A6%EF%BC%8Cn-2%E7%9A%84%E9%80%89%E7%A5%A8/"
      title="【算法作业】次数不小于k的字符，n/2的选票"
     >

    <p class="title-text">
      
        【算法作业】次数不小于k的字符，n/2的选票
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>

 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 日月星辰<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
