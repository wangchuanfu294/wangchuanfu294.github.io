<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  <title>【算法实验】解题实验报告 | 日月星辰的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="计科2205班 蔡明辰  实验一 本实验主要是分治算法  T1 快速排序及第k小数问题描述实现快速排序算法，并利用快速排序算法的思想解决第k小数的问题。 解题思路 快速排序：快速排序是一种分治算法，通过选择一个”枢轴”元素，将数组分成左右两个部分，左边部分的元素都小于或等于枢轴，右边部分的元素都大于或等于枢轴，然后递归地对左右两部分进行排序。  第k小数：可以利用快速排序的思想，通过每次划分数组">
<meta property="og:type" content="article">
<meta property="og:title" content="【算法实验】解题实验报告">
<meta property="og:url" content="http://example.com/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E3%80%91%E8%A7%A3%E9%A2%98%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html">
<meta property="og:site_name" content="日月星辰的个人博客">
<meta property="og:description" content="计科2205班 蔡明辰  实验一 本实验主要是分治算法  T1 快速排序及第k小数问题描述实现快速排序算法，并利用快速排序算法的思想解决第k小数的问题。 解题思路 快速排序：快速排序是一种分治算法，通过选择一个”枢轴”元素，将数组分成左右两个部分，左边部分的元素都小于或等于枢轴，右边部分的元素都大于或等于枢轴，然后递归地对左右两部分进行排序。  第k小数：可以利用快速排序的思想，通过每次划分数组">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E3%80%91%E8%A7%A3%E9%A2%98%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/1.png">
<meta property="og:image" content="http://example.com/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E3%80%91%E8%A7%A3%E9%A2%98%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/2.png">
<meta property="og:image" content="http://example.com/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E3%80%91%E8%A7%A3%E9%A2%98%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/3.png">
<meta property="article:published_time" content="2024-06-29T09:04:19.000Z">
<meta property="article:modified_time" content="2024-07-02T10:21:53.981Z">
<meta property="article:author" content="cmc">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E3%80%91%E8%A7%A3%E9%A2%98%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/1.png">
  
    <link rel="alternate" href="/atom.xml" title="日月星辰的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/avatar.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/./assets/banner.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>日月星辰的个人博客 </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS Feed">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="Search" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS Feed">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/./assets/avatar.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">日月星辰 </div>
      <div class="dot"></div>
      <div class="subtitle">一个不想拯救世界的技术宅 </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/m0_72845244?type=blog" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/m0_72845244?type=blog" title="Steam"><i class="fa-brands fa-steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/wangchuanfu294" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      



    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Tags</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%AE%89%E5%8D%93-%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91/" rel="tag">安卓&#x2F;鸿蒙开发</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" rel="tag">嵌入式开发</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/" rel="tag">生活随笔</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" rel="tag">目标检测</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%89%B9%E8%AE%AD%E8%90%A5/" rel="tag">算法特训营</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Archives</h3>
      
      
        <a class="archive-link" href="/archives/2024/06 ">
          June 2024 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/05 ">
          May 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/04 ">
          April 2024 
          <div class="archive-count">5 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/03 ">
          March 2024 
          <div class="archive-count">7 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/02 ">
          February 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/01 ">
          January 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/12 ">
          December 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/09 ">
          September 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/08 ">
          August 2023 
          <div class="archive-count">6 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/07 ">
          July 2023 
          <div class="archive-count">15 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Recent Posts</h3>
      <ul>
        
          <li>
            <a href="/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E3%80%91%E8%A7%A3%E9%A2%98%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">【算法实验】解题实验报告</a>
          </li>
        
          <li>
            <a href="/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E3%80%91%E9%83%A8%E5%88%86%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-%E4%B8%8B/">【算法题解】部分洛谷题解(下)</a>
          </li>
        
          <li>
            <a href="/2024/05/08/%E3%80%90%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E3%80%91%E6%91%8A%E5%88%86%E5%8D%A1%E7%89%8C%EF%BC%8C%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8/">【算法作业】均分卡牌，购买股票</a>
          </li>
        
          <li>
            <a href="/2024/04/30/%E3%80%90%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E3%80%91%E6%9C%80%E5%B0%91%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%BC%80%E8%AE%BE%E5%88%86%E5%85%AC%E5%8F%B8/">【算法作业】最少分割回文字符串，开设分公司</a>
          </li>
        
          <li>
            <a href="/2024/04/17/%E6%A0%91%E8%8E%93%E6%B4%BE-Openwrt%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%EF%BC%8C%E6%89%93%E7%A0%B4%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%AE%BE%E5%A4%87%E9%99%90%E5%88%B6/">树莓派+Openwrt连接校园网，打破校园网设备限制</a>
          </li>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-【算法实验】解题实验报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        【算法实验】解题实验报告
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-06-29T09:04:19.000Z" itemprop="datePublished">2024-06-29</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
    Uncategorized 
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            5.2k words 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <blockquote>
<p>计科2205班 蔡明辰</p>
</blockquote>
<h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><blockquote>
<p>本实验主要是分治算法</p>
</blockquote>
<h2 id="T1-快速排序及第k小数"><a href="#T1-快速排序及第k小数" class="headerlink" title="T1 快速排序及第k小数"></a>T1 快速排序及第k小数</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>实现快速排序算法，并利用快速排序算法的思想解决第k小数的问题。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p><strong>快速排序</strong>：快速排序是一种分治算法，通过选择一个”枢轴”元素，将数组分成左右两个部分，左边部分的元素都小于或等于枢轴，右边部分的元素都大于或等于枢轴，然后递归地对左右两部分进行排序。</p>
</li>
<li><p><strong>第k小数</strong>：可以利用快速排序的思想，通过每次划分数组，确定第k小数所在的位置，如果这个位置恰好是k，那么找到了第k小数；如果位置小于k，则第k小数在右边部分；如果位置大于k，则第k小数在左边部分。</p>
</li>
</ol>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(arr, left, right);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[right];</span><br><span class="line">    <span class="type">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[right]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a>第k小数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[right];</span><br><span class="line">    <span class="type">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[right]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(arr, left, right);</span><br><span class="line">    <span class="keyword">if</span> (k == pivotIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[k];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; pivotIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(arr, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(arr, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">26</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> k = <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;rd smallest element is &quot;</span> &lt;&lt; <span class="built_in">quickSelect</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>, k - <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-棋盘覆盖问题"><a href="#T2-棋盘覆盖问题" class="headerlink" title="T2 棋盘覆盖问题"></a>T2 棋盘覆盖问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>在一个 $2^k \times 2^k $ 个方格组成的棋盘中，恰有一个方格与其它方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖</p>
<p><img src="/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E3%80%91%E8%A7%A3%E9%A2%98%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/1.png"></p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><strong>分治法</strong>：将大棋盘划分为4个子棋盘，每个子棋盘的大小为 $2^{k-1} \times 2^{k-1}$。</li>
<li><strong>放置L型骨牌</strong>：确定4个子棋盘中的哪个包含特殊方格，然后在另外3个子棋盘的交汇处放置一个L型骨牌，使得这3个子棋盘各自有一个新的特殊方格。</li>
<li><strong>递归覆盖</strong>：递归处理每个子棋盘，直到子棋盘的大小为 $2 \times 2$ 时，直接用一个L型骨牌覆盖。</li>
</ol>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1024</span>;  <span class="comment">// 最大棋盘大小</span></span><br><span class="line"><span class="type">int</span> board[MAXN][MAXN];  <span class="comment">// 棋盘</span></span><br><span class="line"><span class="type">int</span> tile = <span class="number">1</span>;           <span class="comment">// L型骨牌标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coverBoard</span><span class="params">(<span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = tile++;  <span class="comment">// 当前L型骨牌标记</span></span><br><span class="line">    <span class="type">int</span> s = size / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖左上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line">        <span class="built_in">coverBoard</span>(tr, tc, dr, dc, s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        <span class="built_in">coverBoard</span>(tr, tc, tr + s - <span class="number">1</span>, tc + s - <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖右上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line">        <span class="built_in">coverBoard</span>(tr, tc + s, dr, dc, s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s] = t;</span><br><span class="line">        <span class="built_in">coverBoard</span>(tr, tc + s, tr + s - <span class="number">1</span>, tc + s, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖左下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line">        <span class="built_in">coverBoard</span>(tr + s, tc, dr, dc, s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        board[tr + s][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        <span class="built_in">coverBoard</span>(tr + s, tc, tr + s, tc + s - <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖右下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line">        <span class="built_in">coverBoard</span>(tr + s, tc + s, dr, dc, s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        board[tr + s][tc + s] = t;</span><br><span class="line">        <span class="built_in">coverBoard</span>(tr + s, tc + s, tr + s, tc + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印棋盘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBoard</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; board[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">3</span>;  <span class="comment">// 棋盘大小2^k</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">    <span class="type">int</span> dr = <span class="number">1</span>, dc = <span class="number">2</span>;  <span class="comment">// 特殊方格位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">coverBoard</span>(<span class="number">0</span>, <span class="number">0</span>, dr, dc, n);</span><br><span class="line">    <span class="built_in">printBoard</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3  3  4  4  8  8  9  9</span><br><span class="line">3  2  0  4  8  7  7  9</span><br><span class="line">5  2  2  6  10 10 7  11</span><br><span class="line">5  5  6  6  1  10 11 11</span><br><span class="line">13 13 14 1  1  18 19 19</span><br><span class="line">13 12 14 14 18 18 17 19</span><br><span class="line">15 12 12 16 20 17 17 21</span><br><span class="line">15 15 16 16 20 20 21 21</span><br></pre></td></tr></table></figure>

<p>其中的数字0就代表特殊方格，没有填入骨牌。</p>
<h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1><blockquote>
<p>本实验主要考察的是<strong>动态规划</strong></p>
</blockquote>
<h2 id="T1-计算矩阵连乘积"><a href="#T1-计算矩阵连乘积" class="headerlink" title="T1 计算矩阵连乘积"></a>T1 计算矩阵连乘积</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>这个问题是经典的矩阵链乘问题，目的是找到一种最优的计算顺序，使得计算矩阵连乘的总次数最少。下面是对程序的详细解释和修改后的代码，确保可以正确计算最小的数乘次数。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><strong>问题定义</strong>：给定n个矩阵，要求找到计算矩阵连乘积的最优顺序，使得计算的数乘次数最少。</li>
<li><strong>递归公式</strong>：<ul>
<li>设 $ m[i][j] $ 表示计算从矩阵 $ A_i $ 到 $ A_j $ 的最小数乘次数。</li>
<li>设 $ p $ 是矩阵的维数数组，表示矩阵 $ A_i $ 的维数为 $ p[i-1] \times p[i] $。</li>
<li>初始条件：  m[i][i] &#x3D; 0 。</li>
<li>递归公式：<br>$$<br>m[i][j] &#x3D; \min_{i \leq k &lt; j} { m[i][k] + m[k+1][j] + p[i-1] \times p[k] \times p[j] }<br>$$</li>
</ul>
</li>
<li><strong>实现步骤</strong>：<ul>
<li>读入矩阵的维数数组  p 。</li>
<li>初始化  m[i][i] &#x3D; 0 。</li>
<li>使用递归公式计算  m[i][j] 。</li>
</ul>
</li>
</ol>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">101</span>], i, j, k, r, t, n;</span><br><span class="line">    <span class="type">int</span> m[<span class="number">101</span>][<span class="number">101</span>]; <span class="comment">// m[i][j]表示计算从矩阵Ai到Aj的最小数乘次数</span></span><br><span class="line">    <span class="type">int</span> s[<span class="number">101</span>][<span class="number">101</span>]; <span class="comment">// 记录从第i到第j个矩阵连乘的断开位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入矩阵的数量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]); <span class="comment">// 读入矩阵的维数数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化m[i][i]=0，即单个矩阵的连乘次数为0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        m[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算矩阵连乘的最小数乘次数</span></span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt; n; r++) &#123; <span class="comment">// r为i、j相差的值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - r; i++) &#123; <span class="comment">// i为行</span></span><br><span class="line">            j = i + r; <span class="comment">// j为列</span></span><br><span class="line">            m[i][j] = m[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j]; <span class="comment">// 给m[i][j]赋初值</span></span><br><span class="line">            s[i][j] = i; <span class="comment">// 记录断开位置</span></span><br><span class="line">            <span class="keyword">for</span> (k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                t = m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) &#123;</span><br><span class="line">                    m[i][j] = t; <span class="comment">// m[i][j]取最小值</span></span><br><span class="line">                    s[i][j] = k; <span class="comment">// 记录断开位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小的数乘次数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m[<span class="number">1</span>][n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-防卫导弹"><a href="#T2-防卫导弹" class="headerlink" title="T2 防卫导弹"></a>T2 防卫导弹</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>一种新型的防卫导弹可截击多个攻击导弹。它可以向前飞行，也可以用很快的速度向下飞行，可以毫无损伤地截击进攻导弹，但不可以向后或向上飞行。但有一个缺点，尽管它发射时可以达到任意高度，但它只能截击比它上次截击导弹时所处高度低或者高度相同的导弹。现对这种新型防卫导弹进行测试，在每一次测试中，发射一系列的测试导弹（这些导弹发射的间隔时间固定，飞行速度相同），该防卫导弹所能获得的信息包括各进攻导弹的高度，以及它们发射次序。现要求编一程序，求在每次测试中，该防卫导弹最多能截击的进攻导弹数量，一个导弹能被截击应满足下列两个条件之一：</p>
<ol>
<li>它是该次测试中第一个被防卫导弹截击的导弹；</li>
<li>它是在上一次被截击导弹的发射后发射，且高度不大于上一次被截击导弹的高度的导弹。</li>
</ol>
<p>输入数据：第一行是一个整数n，以后的n各有一个整数表示导弹的高度。</p>
<p>输出数据：截击导弹的最大数目。</p>
<p>分析：定义l[i]为选择截击第i个导弹，从这个导弹开始最多能截击的导弹数目。</p>
<p>由于选择了第i枚导弹，所以下一个要截击的导弹j的高度要小于等于它的高度，所以l[i]应该等于从i＋1到n的每一个j，满足h[j]&lt;&#x3D;h[i]的j中l[j]的最大值。</p>
<p>这个问题可以通过动态规划来解决。目标是找出最长的非递增子序列（Longest Non-Increasing Subsequence, LNIS），即最多可以截击的导弹数量。以下是对程序的解释以及代码：</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p><strong>定义状态</strong>：</p>
<ul>
<li>设 $ l[i] $ 为选择截击第 $ i $ 个导弹后，从这个导弹开始最多能截击的导弹数目。</li>
</ul>
</li>
<li><p><strong>状态转移方程</strong>：</p>
<ul>
<li>如果选择截击第 $ i $ 个导弹，那么下一个要截击的导弹 $ j $ 的高度必须小于等于第 $ i $ 个导弹的高度。所以：<br>$$<br>l[i] &#x3D; \max_{i &lt; j \leq n} { l[j] } + 1 \quad \text{其中} \quad h[j] \leq h[i]<br>$$</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>最后一个导弹只能截击自己，所以 $ l[n-1] &#x3D; 1 $。</li>
</ul>
</li>
<li><p><strong>结果</strong>：</p>
<ul>
<li>输出 $ l[0] $，即从第一个导弹开始最多能截击的导弹数目。</li>
</ul>
</li>
</ol>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, max, h[<span class="number">100</span>], l[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读入导弹数量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读入各个导弹的高度</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化最后一个导弹的截击数目</span></span><br><span class="line">    l[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逆向遍历导弹</span></span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt;= h[j] &amp;&amp; max &lt; l[j])</span><br><span class="line">                max = l[j];</span><br><span class="line">        l[i] = max + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出从第一个导弹开始最多能截击的导弹数目</span></span><br><span class="line">    max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (l[i] &gt; max)</span><br><span class="line">            max = l[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3-皇宫看守"><a href="#T3-皇宫看守" class="headerlink" title="T3 皇宫看守"></a>T3 皇宫看守</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>太平王世子事件后，陆小凤成了皇上特聘的御前一品侍卫。皇宫以午门为起点，直到后宫嫔妃们的寝宫，呈一棵树的形状；某些宫殿间可以互相望见。大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。可是陆小凤手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。</p>
<p>请你编程计算帮助陆小凤布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。</p>
<p>输入数据：输入数据由文件名为intput.txt的文本文件提供。输入文件中数据表示一棵树，描述如下：</p>
<p>第1行 n，表示树中结点的数目。</p>
<p>第2行至第n+1行，每行描述每个宫殿结点信息，依次为：该宫殿结点标号i(0&lt;i&lt;&#x3D;n)，在该宫殿安置侍卫所需的经费k，该边的儿子数m，接下来m个数，分别是这个节点的m个儿子的标号r1，r2，…，rm。</p>
<p>对于一个n（0 &lt; n &lt;&#x3D; 1500）个结点的树，结点标号在1到n之间，且标号不重复。</p>
<p>输出数据：输出到output.txt文件中。输出文件仅包含一个数，为所求的最少的经费。</p>
<p>如右图的输入数据示例：<img src="/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E3%80%91%E8%A7%A3%E9%A2%98%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/2.png"></p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 </span><br><span class="line">1 30 3 2 3 4</span><br><span class="line">2 16 2 5 6</span><br><span class="line">3 5 0</span><br><span class="line">4 4 0</span><br><span class="line">5 11 0</span><br><span class="line">6 5 0</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来求解此问题。定义 <code>dp[i][0]</code> 表示以节点 <code>i</code> 为根节点的子树中，不在节点 <code>i</code> 上安排侍卫的最小花费；<code>dp[i][1]</code> 表示以节点 <code>i</code> 为根节点的子树中，在节点 <code>i</code> 上安排侍卫的最小花费。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化每个节点的费用和子节点信息。</li>
<li>使用深度优先搜索（DFS）遍历整棵树，并在遍历过程中计算每个节点的 dp 值。</li>
<li>根节点的两个 dp 值中的较小值即为所需的最小费用。</li>
</ol>
<h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1505</span>;</span><br><span class="line"><span class="type">int</span> cost[MAXN];  <span class="comment">// 保存每个节点的费用</span></span><br><span class="line"><span class="type">int</span> dp[MAXN][<span class="number">2</span>]; <span class="comment">// dp[i][0]表示不在节点i上安排侍卫的最小费用，dp[i][1]表示在节点i上安排侍卫的最小费用</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[MAXN]; <span class="comment">// 存储树的结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 不在节点u上安排侍卫的最小费用初始化为0</span></span><br><span class="line">    dp[u][<span class="number">1</span>] = cost[u]; <span class="comment">// 在节点u上安排侍卫的最小费用初始化为节点u的费用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : tree[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v); <span class="comment">// 深度优先搜索遍历子节点v</span></span><br><span class="line">        dp[u][<span class="number">0</span>] += dp[v][<span class="number">1</span>]; <span class="comment">// 若不在u节点安排侍卫，则子节点必须安排侍卫</span></span><br><span class="line">        dp[u][<span class="number">1</span>] += <span class="built_in">min</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]); <span class="comment">// 若在u节点安排侍卫，子节点可安排或不安排侍卫，取最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cost, <span class="number">0</span>, <span class="built_in">sizeof</span>(cost));</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> id, k, m;</span><br><span class="line">        cin &gt;&gt; id &gt;&gt; k &gt;&gt; m;</span><br><span class="line">        cost[id] = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> child;</span><br><span class="line">            cin &gt;&gt; child;</span><br><span class="line">            tree[id].<span class="built_in">push_back</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">// 假设节点1为根节点进行dfs</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 </span><br><span class="line">1 30 3 2 3 4</span><br><span class="line">2 16 2 5 6</span><br><span class="line">3 5 0</span><br><span class="line">4 4 0</span><br><span class="line">5 11 0</span><br><span class="line">6 5 0</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>

<h1 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h1><blockquote>
<p>本实验主要是贪心算法和随机算法</p>
</blockquote>
<h2 id="T1-背包问题"><a href="#T1-背包问题" class="headerlink" title="T1 背包问题"></a>T1 背包问题</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>有一个背包，背包容量是M&#x3D;150。有7个物品，物品可以分割成任意大小。</p>
<p>要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody><tr>
<td>重量</td>
<td>35</td>
<td>30</td>
<td>60</td>
<td>50</td>
<td>40</td>
<td>10</td>
<td>25</td>
</tr>
<tr>
<td>价值</td>
<td>10</td>
<td>40</td>
<td>30</td>
<td>50</td>
<td>35</td>
<td>40</td>
<td>30</td>
</tr>
</tbody></table>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>计算每个物品的单位重量价值（价值&#x2F;重量）。</li>
<li>按照单位重量价值从大到小排序物品。</li>
<li>依次选择物品装入背包，直到背包达到最大容量M。</li>
</ol>
<h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义物品结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">    <span class="type">double</span> unitValue; <span class="comment">// 单位重量价值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于按单位重量价值从大到小排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Item a, Item b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.unitValue &gt; b.unitValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 背包容量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> M = <span class="number">150.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 物品信息</span></span><br><span class="line">    vector&lt;Item&gt; items = &#123;</span><br><span class="line">        &#123;<span class="number">35</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">        &#123;<span class="number">60</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="number">50</span>, <span class="number">50</span>&#125;,</span><br><span class="line">        &#123;<span class="number">40</span>, <span class="number">35</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">40</span>&#125;,</span><br><span class="line">        &#123;<span class="number">25</span>, <span class="number">30</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算每个物品的单位重量价值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : items) &#123;</span><br><span class="line">        item.unitValue = item.value / item.weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按单位重量价值从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), compare);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> totalValue = <span class="number">0.0</span>; <span class="comment">// 背包中物品的总价值</span></span><br><span class="line">    <span class="type">double</span> currentWeight = <span class="number">0.0</span>; <span class="comment">// 背包当前重量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentWeight + item.weight &lt;= M) &#123;</span><br><span class="line">            <span class="comment">// 如果当前物品能完全装入背包</span></span><br><span class="line">            currentWeight += item.weight;</span><br><span class="line">            totalValue += item.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前物品不能完全装入背包，装入部分</span></span><br><span class="line">            <span class="type">double</span> remainWeight = M - currentWeight;</span><br><span class="line">            totalValue += item.unitValue * remainWeight;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;背包中物品的最大总价值: &quot;</span> &lt;&lt; totalValue &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="T2-照亮的山景"><a href="#T2-照亮的山景" class="headerlink" title="T2 照亮的山景"></a>T2 照亮的山景</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>在一片山的上空，高度为T处有N个处于不同位置的灯泡，如图。如果山的边界上某一点于某灯i的连线不经过山的其它点，我们称灯i可以照亮该点。开尽量少的灯，使得整个山景都被照亮。山被表示成有m个转折点的折线。</p>
<p>提示：照亮整个山景相当于照亮每一个转折点。</p>
<p><img src="/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E3%80%91%E8%A7%A3%E9%A2%98%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/3.png"></p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个问题类似于一个覆盖问题，目标是使用尽量少的灯泡照亮整个山景。我们可以通过几何方法来解决这个问题。</p>
<ol>
<li><strong>输入处理</strong>：读取山的转折点和灯泡的位置。</li>
<li><strong>可见性判断</strong>：判断每个灯泡是否能够照亮每个转折点。</li>
<li><strong>集合覆盖问题</strong>：使用<strong>贪心算法</strong>解决最小集合覆盖问题，即选择尽量少的灯泡照亮所有转折点。</li>
</ol>
<h3 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算叉积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">crossProduct</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断p1到p2的直线是否与山的折线相交</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isVisible</span><span class="params">(Point p1, Point p2, vector&lt;Point&gt;&amp; mountain)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mountain.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">crossProduct</span>(p1, mountain[i], p2) * <span class="built_in">crossProduct</span>(p1, mountain[i + <span class="number">1</span>], p2) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">crossProduct</span>(mountain[i], p1, mountain[i + <span class="number">1</span>]) * <span class="built_in">crossProduct</span>(mountain[i], p2, mountain[i + <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T, N, M;</span><br><span class="line">    cin &gt;&gt; T &gt;&gt; N &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Point&gt; <span class="title">bulbs</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; bulbs[i].x &gt;&gt; bulbs[i].y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Point&gt; <span class="title">mountain</span><span class="params">(M)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; mountain[i].x &gt;&gt; mountain[i].y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visibility</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isVisible</span>(bulbs[i], mountain[j], mountain)) &#123;</span><br><span class="line">                visibility[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">covered</span><span class="params">(M, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> minBulbs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> maxCover = <span class="number">0</span>, bestBulb = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!covered[j] &amp;&amp; visibility[i][j]) &#123;</span><br><span class="line">                    cover++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cover &gt; maxCover) &#123;</span><br><span class="line">                maxCover = cover;</span><br><span class="line">                bestBulb = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxCover == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        minBulbs++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visibility[bestBulb][j]) &#123;</span><br><span class="line">                covered[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最少需要的灯泡数量: &quot;</span> &lt;&lt; minBulbs &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li><strong>输入处理</strong>：读取灯泡和山的转折点坐标。</li>
<li><strong>可见性判断</strong>：利用叉积判断两点连线是否经过山的其他点。</li>
<li><strong>集合覆盖</strong>：使用贪心算法选择最少的灯泡，确保照亮所有转折点。</li>
</ol>
<h3 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h3><p>假设我们有以下输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">T = 100</span><br><span class="line">N = 4</span><br><span class="line">M = 5</span><br><span class="line">灯泡位置:</span><br><span class="line">0 100</span><br><span class="line">50 100</span><br><span class="line">100 100</span><br><span class="line">150 100</span><br><span class="line">山的转折点:</span><br><span class="line">0 0</span><br><span class="line">50 50</span><br><span class="line">100 0</span><br><span class="line">150 50</span><br><span class="line">200 0</span><br></pre></td></tr></table></figure>

<p>运行该程序会输出最少需要的灯泡数量。通过这种方法，我们可以确保以最少的灯泡照亮整个山景。</p>
<h2 id="T3-搬桌子问题"><a href="#T3-搬桌子问题" class="headerlink" title="T3 搬桌子问题"></a>T3 搬桌子问题</h2><h3 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h3><p>某教学大楼一层有n个教室，从左到右依次编号为1、2、…、n。现在要把一些课桌从某些教室搬到另外一些教室，每张桌子都是从编号较小的教室搬到编号较大的教室，每一趟，都是从左到右走，搬完一张课桌后，可以继续从当前位置或往右走搬另一张桌子。输入数据：先输入n、m，然后紧接着m行输入这m张要搬课桌的起始教室和目标教室。</p>
<p>输出数据：最少需要跑几趟。</p>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个问题可以转化为寻找最少的区间覆盖问题。每次搬运一张桌子，可以理解为从一个区间的起始点到结束点的操作。因此，我们需要找到一种方法，能够用最少的区间数覆盖所有搬运任务。</p>
<p>一个有效的解法是使用贪心算法，步骤如下：</p>
<ol>
<li>将所有搬运任务按照起始教室和目标教室进行排序。</li>
<li>使用一个变量跟踪当前的搬运终点位置，初始化为0。</li>
<li>遍历所有搬运任务，对于每一个任务，如果其起始教室在当前搬运终点位置之前，则可以在当前趟次中继续搬运。</li>
<li>否则，增加新的趟次，并更新当前搬运终点位置。</li>
</ol>
<h3 id="完整代码-7"><a href="#完整代码-7" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于按起点和终点排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Task a, Task b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.start == b.start) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.end &lt; b.end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Task&gt; <span class="title">tasks</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; tasks[i].start &gt;&gt; tasks[i].end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按起始教室和目标教室排序</span></span><br><span class="line">    <span class="built_in">sort</span>(tasks.<span class="built_in">begin</span>(), tasks.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> trips = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> currentEnd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks[i].start &gt; currentEnd) &#123;</span><br><span class="line">            <span class="comment">// 如果当前任务的起始教室在当前搬运终点之后，需要新的趟次</span></span><br><span class="line">            trips++;</span><br><span class="line">            currentEnd = tasks[i].end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前任务的起始教室在当前搬运终点之前，可以继续搬运，更新终点</span></span><br><span class="line">            currentEnd = <span class="built_in">max</span>(currentEnd, tasks[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最少需要跑 &quot;</span> &lt;&lt; trips &lt;&lt; <span class="string">&quot; 趟&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><strong>输入处理</strong>：读取教室的数量<code>n</code>和任务的数量<code>m</code>，然后读取每个任务的起始教室和目标教室。</li>
<li><strong>任务排序</strong>：按照起始教室和目标教室对任务进行排序。</li>
<li><strong>贪心算法</strong>：遍历所有任务，根据当前搬运的终点位置决定是否需要新的趟次，更新当前搬运终点位置。</li>
<li><strong>输出结果</strong>：输出最少需要的跑趟数。</li>
</ol>
<p>这样，我们就可以用最少的趟次完成所有搬运任务。</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left  disabled "
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E3%80%91%E9%83%A8%E5%88%86%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-%E4%B8%8B/"
      title="【算法题解】部分洛谷题解(下)"
     >

    <p class="title-text">
      
        【算法题解】部分洛谷题解(下)
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>

 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 日月星辰<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
